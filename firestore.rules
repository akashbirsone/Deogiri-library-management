/**
 * @fileoverview Firestore Security Rules for Prototyping.
 *
 * Core Philosophy:
 * This ruleset prioritizes strict authorization and assumes a flexible data shape for rapid prototyping.
 * It enforces user-ownership where appropriate and defaults to denying access unless explicitly granted.
 *
 * Data Structure:
 * - Users: Stored in `/users/{userId}`. Each user document contains profile information.
 * - Books: Stored in `/departments/{deptId}/courses/{courseId}/semesters/{semId}/subjects/{subjectId}/books/{bookId}`.
 *
 * Key Security Decisions:
 * - Users can only read and write their own user document.
 * - Listing the `/users` collection is denied to all users.
 * - Books are accessible to anyone (public read), but only authenticated users can add, modify, or delete them, based on ownership.
 *
 * Denormalization for Authorization:
 * - Book documents should contain an `addedBy` field to store the user ID of the user who added the book for write operation authorization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data.
     * @path /users/{userId}
     * @allow (create) - If the user's auth UID matches the userId.
     * @allow (get, update, delete) - If the user's auth UID matches the userId.
     * @deny (list) - Listing all users is not permitted.
     * @deny (create) - If the user's auth UID does not match the userId.
     * @deny (update, delete) - If the user's auth UID does not match the userId.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      // Only signed-in users can access their own data.
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false; // Listing users is not permitted

      // Users can create their own profile, but the ID must match their auth UID.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.uid == userId;

      // Users can update/delete their own profile, only if it exists.
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to the book catalog.
     * @path /departments/{deptId}/courses/{courseId}/semesters/{semId}/subjects/{subjectId}/books/{bookId}
     * @allow (get, list) - Public read access.
     * @allow (create) - Only authenticated users can create a book, and `addedBy` field must match the user's UID.
     * @allow (update, delete) - Only the user who added the book (`addedBy` field) can modify or delete it, and only if the book exists.
     * @deny (create) - If the `addedBy` field does not match the user's UID.
     * @deny (update, delete) - If the book does not exist or the user is not the owner (`addedBy` field).
     * @principle Allows public reads, restricts writes to the owner.
     */
    match /departments/{deptId}/courses/{courseId}/semesters/{semId}/subjects/{subjectId}/books/{bookId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.addedBy == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingBookOwner(resource.data.addedBy);
    }

    // --- Helper functions ---

    // Checks if the user is signed in.
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the request is made by the owner of the resource.
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Checks if the request is made by the existing owner of the resource and the resource exists
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    // Checks if the request is made by the existing owner of the book and the book exists
    function isExistingBookOwner(ownerId) {
        return request.auth.uid == ownerId && resource != null;
    }
  }
}